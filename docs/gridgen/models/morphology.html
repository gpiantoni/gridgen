<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gridgen.models.morphology API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gridgen.models.morphology</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from numpy import dot, arccos, pi, zeros, cross, dtype, nanmin, NaN, errstate, ones, einsum
from numpy.linalg import norm
from scipy.stats import norm as normal_dist

from ..io import WIRE

d_ = dtype([
    (&#39;label&#39;, &#39;&lt;U256&#39;),   # labels cannot be longer than 256 char
    (&#39;value&#39;, &#39;f4&#39;),
    ])

EPSILON = 1e-5


def compute_morphology(grid, pial, distance=&#39;minimum&#39;, maximum_distance=None, penalty=1):
    if distance == &#39;ray&#39;:
        dist = _distance_ray(grid, pial)

    elif distance == &#39;minimum&#39;:
        dist = _distance_minimum(grid, pial)

    elif distance == &#39;view&#39;:
        dist = _distance_view(grid, pial)

    elif distance == &#39;cylinder&#39;:
        dist = _distance_cylinder(grid, pial)

    elif distance == &#39;pdf&#39;:
        dist = _distance_pdf(grid, pial)

    if maximum_distance and distance in (&#39;ray&#39;, &#39;minimum&#39;):
        with errstate(invalid=&#39;ignore&#39;):
            i = dist[&#39;value&#39;] &gt; maximum_distance
        dist[&#39;value&#39;][i] = NaN

    dist[&#39;value&#39;] = dist[&#39;value&#39;] ** (-1 * penalty)

    return dist


def _distance_ray(grid, pial):
    distance = zeros((grid.shape[0], grid.shape[1]), dtype=d_)
    distance[&#39;value&#39;].fill(NaN)

    for i_x in range(grid.shape[0]):
        for i_y in range(grid.shape[1]):
            if grid[&#39;label&#39;][i_x, i_y] != WIRE:
                dist = intersect_ray_triangle(
                    pial[&#39;pos&#39;][pial[&#39;tri&#39;][:, 0], :],
                    pial[&#39;pos&#39;][pial[&#39;tri&#39;][:, 1], :],
                    pial[&#39;pos&#39;][pial[&#39;tri&#39;][:, 2], :],
                    grid[&#39;pos&#39;][i_x, i_y],
                    -1 * grid[&#39;norm&#39;][i_x, i_y],
                    line=True
                    )

                distance[&#39;value&#39;][i_x, i_y] = nanmin(dist)

    distance[&#39;label&#39;] = grid[&#39;label&#39;]
    return distance


def _distance_minimum(grid, pial):
    distance = zeros((grid.shape[0], grid.shape[1]), dtype=d_)

    for i_x in range(grid.shape[0]):
        for i_y in range(grid.shape[1]):
            if grid[&#39;label&#39;][i_x, i_y] == WIRE:
                continue
            distance[&#39;value&#39;][i_x, i_y] = norm(pial[&#39;pos&#39;] - grid[&#39;pos&#39;][i_x, i_y], axis=1).min()

    distance[&#39;label&#39;] = grid[&#39;label&#39;]
    return distance


def _distance_view(grid, pial):
    max_dist = 8
    max_angle = 15
    distance = zeros((grid.shape[0], grid.shape[1]), dtype=d_)
    distance[&#39;value&#39;][:, :] = max_dist

    for i_x in range(grid.shape[0]):
        for i_y in range(grid.shape[1]):

            pos = grid[&#39;pos&#39;][i_x, i_y]
            norm0 = grid[&#39;norm&#39;][i_x, i_y]

            points = pial[&#39;pos&#39;][norm(pial[&#39;pos&#39;] - pos, axis=1) &lt; max_dist, :]
            directions = (points - pos) / norm(points - pos, axis=1)[:, None]
            x = arccos(dot(directions, norm0 * -1)) / pi * 180
            if x.min() &gt;= max_angle:
                continue
            distance[&#39;value&#39;][i_x, i_y] = norm(points[x &lt;= max_angle, :] - pos, axis=1).min()

    distance[&#39;label&#39;] = grid[&#39;label&#39;]
    return distance


def _distance_cylinder(grid, pial):
    max_dist_to_elec = 100
    max_dist_to_line = 5
    distance = zeros((grid.shape[0], grid.shape[1]), dtype=d_)
    distance[&#39;value&#39;][:, :] = max_dist_to_elec

    for i_x in range(grid.shape[0]):
        for i_y in range(grid.shape[1]):

            pos = grid[&#39;pos&#39;][i_x, i_y]
            norm0 = grid[&#39;norm&#39;][i_x, i_y]

            d = norm(pial[&#39;pos&#39;] - pos, axis=1)
            # points = pial[&#39;pos&#39;][d &lt; max_dist_to_elec, :]
            dist_to_line = norm(cross(norm0, pos - pial[&#39;pos&#39;]), axis=1)
            distance[&#39;value&#39;][i_x, i_y] = d[dist_to_line &lt; max_dist_to_line].min()

    distance[&#39;label&#39;] = grid[&#39;label&#39;]
    return distance


def _distance_pdf(grid, pial):
    distance = zeros((grid.shape[0], grid.shape[1]), dtype=d_)

    for i_x in range(grid.shape[0]):
        for i_y in range(grid.shape[1]):
            distance[&#39;value&#39;][i_x, i_y] = normal_dist.pdf(norm(pial[&#39;pos&#39;] - grid[&#39;pos&#39;][i_x, i_y], axis=1), scale=2).sum()

    distance[&#39;label&#39;] = grid[&#39;label&#39;]
    return distance


def intersect_ray_triangle(vertex0, vertex1, vertex2, rayOrigin, rayVector, line=False):
    &#34;&#34;&#34;Implementation of the Möller-Trumbore algorithm to detect ray-triangle
    intersection.


    Parameters
    ----------
    vertex0 : (n, 3) array
        the first vertex for all the triangles of the mesh
    vertex1 : (n, 3) array
        the second vertex for all the triangles of the mesh
    vertex2 : (n, 3) array
        the third vertex for all the triangles of the mesh
    rayOrigin : (3, ) array
        start position of the ray
    rayVector : (3, ) array
        direction of the ray vector
    line : bool
        if False, the sign of the normal is important (treated as a ray, leaving rayOrigin).
        if True, it detects intersection in both direction (treated as a line
        with two directions)

    Returns
    -------
    array (n, )
        distance of each triangle to the point of interest. It&#39;s NaN if 1.
        the direction of the point is parallel to the triangle, 2. the projected
        point is outside the triangle, 3. the direction is in the opposite direction
        to the triangle (so, this is a ray, not a line).

    Notes
    -----
    Implementation derived from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    &#34;&#34;&#34;
    i_good = ones(vertex0.shape[0], dtype=bool)
    edge1 = vertex1 - vertex0
    edge2 = vertex2 - vertex0
    h = cross(rayVector, edge2, axis=-1)
    a = einsum(&#39;ij,ij-&gt;i&#39;, edge1, h)  # dot product

    i_parallel = (a &gt; -EPSILON) &amp; (a &lt; EPSILON)
    i_good[i_parallel] = False

    f = 1 / a

    s = rayOrigin - vertex0
    u = f * einsum(&#39;ij,ij-&gt;i&#39;, s, h)
    i_outside = (u &lt; 0.0) | (u &gt; 1.0)
    i_good[i_outside] = False

    q = cross(s, edge1)
    v = f * einsum(&#39;j,ij-&gt;i&#39;, rayVector, q)

    i_outside = (v &lt; 0.0) | (u + v &gt; 1.0)
    i_good[i_outside] = False

    t = f * einsum(&#39;ij,ij-&gt;i&#39;, edge2, q)
    if not line:
        i_opposite = t &lt; EPSILON
        i_good[i_opposite] = NaN

    t[~i_good] = NaN

    return t</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gridgen.models.morphology.compute_morphology"><code class="name flex">
<span>def <span class="ident">compute_morphology</span></span>(<span>grid, pial, distance='minimum', maximum_distance=None, penalty=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_morphology(grid, pial, distance=&#39;minimum&#39;, maximum_distance=None, penalty=1):
    if distance == &#39;ray&#39;:
        dist = _distance_ray(grid, pial)

    elif distance == &#39;minimum&#39;:
        dist = _distance_minimum(grid, pial)

    elif distance == &#39;view&#39;:
        dist = _distance_view(grid, pial)

    elif distance == &#39;cylinder&#39;:
        dist = _distance_cylinder(grid, pial)

    elif distance == &#39;pdf&#39;:
        dist = _distance_pdf(grid, pial)

    if maximum_distance and distance in (&#39;ray&#39;, &#39;minimum&#39;):
        with errstate(invalid=&#39;ignore&#39;):
            i = dist[&#39;value&#39;] &gt; maximum_distance
        dist[&#39;value&#39;][i] = NaN

    dist[&#39;value&#39;] = dist[&#39;value&#39;] ** (-1 * penalty)

    return dist</code></pre>
</details>
</dd>
<dt id="gridgen.models.morphology.intersect_ray_triangle"><code class="name flex">
<span>def <span class="ident">intersect_ray_triangle</span></span>(<span>vertex0, vertex1, vertex2, rayOrigin, rayVector, line=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implementation of the Möller-Trumbore algorithm to detect ray-triangle
intersection.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>vertex0</code></strong> :&ensp;<code>(n, 3) array</code></dt>
<dd>the first vertex for all the triangles of the mesh</dd>
<dt><strong><code>vertex1</code></strong> :&ensp;<code>(n, 3) array</code></dt>
<dd>the second vertex for all the triangles of the mesh</dd>
<dt><strong><code>vertex2</code></strong> :&ensp;<code>(n, 3) array</code></dt>
<dd>the third vertex for all the triangles of the mesh</dd>
<dt><strong><code>rayOrigin</code></strong> :&ensp;<code>(3, ) array</code></dt>
<dd>start position of the ray</dd>
<dt><strong><code>rayVector</code></strong> :&ensp;<code>(3, ) array</code></dt>
<dd>direction of the ray vector</dd>
<dt><strong><code>line</code></strong> :&ensp;<code>bool</code></dt>
<dd>if False, the sign of the normal is important (treated as a ray, leaving rayOrigin).
if True, it detects intersection in both direction (treated as a line
with two directions)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array (n, )</code></dt>
<dd>distance of each triangle to the point of interest. It's NaN if 1.
the direction of the point is parallel to the triangle, 2. the projected
point is outside the triangle, 3. the direction is in the opposite direction
to the triangle (so, this is a ray, not a line).</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Implementation derived from <a href="https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm">https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def intersect_ray_triangle(vertex0, vertex1, vertex2, rayOrigin, rayVector, line=False):
    &#34;&#34;&#34;Implementation of the Möller-Trumbore algorithm to detect ray-triangle
    intersection.


    Parameters
    ----------
    vertex0 : (n, 3) array
        the first vertex for all the triangles of the mesh
    vertex1 : (n, 3) array
        the second vertex for all the triangles of the mesh
    vertex2 : (n, 3) array
        the third vertex for all the triangles of the mesh
    rayOrigin : (3, ) array
        start position of the ray
    rayVector : (3, ) array
        direction of the ray vector
    line : bool
        if False, the sign of the normal is important (treated as a ray, leaving rayOrigin).
        if True, it detects intersection in both direction (treated as a line
        with two directions)

    Returns
    -------
    array (n, )
        distance of each triangle to the point of interest. It&#39;s NaN if 1.
        the direction of the point is parallel to the triangle, 2. the projected
        point is outside the triangle, 3. the direction is in the opposite direction
        to the triangle (so, this is a ray, not a line).

    Notes
    -----
    Implementation derived from https://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
    &#34;&#34;&#34;
    i_good = ones(vertex0.shape[0], dtype=bool)
    edge1 = vertex1 - vertex0
    edge2 = vertex2 - vertex0
    h = cross(rayVector, edge2, axis=-1)
    a = einsum(&#39;ij,ij-&gt;i&#39;, edge1, h)  # dot product

    i_parallel = (a &gt; -EPSILON) &amp; (a &lt; EPSILON)
    i_good[i_parallel] = False

    f = 1 / a

    s = rayOrigin - vertex0
    u = f * einsum(&#39;ij,ij-&gt;i&#39;, s, h)
    i_outside = (u &lt; 0.0) | (u &gt; 1.0)
    i_good[i_outside] = False

    q = cross(s, edge1)
    v = f * einsum(&#39;j,ij-&gt;i&#39;, rayVector, q)

    i_outside = (v &lt; 0.0) | (u + v &gt; 1.0)
    i_good[i_outside] = False

    t = f * einsum(&#39;ij,ij-&gt;i&#39;, edge2, q)
    if not line:
        i_opposite = t &lt; EPSILON
        i_good[i_opposite] = NaN

    t[~i_good] = NaN

    return t</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gridgen.models" href="index.html">gridgen.models</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gridgen.models.morphology.compute_morphology" href="#gridgen.models.morphology.compute_morphology">compute_morphology</a></code></li>
<li><code><a title="gridgen.models.morphology.intersect_ray_triangle" href="#gridgen.models.morphology.intersect_ray_triangle">intersect_ray_triangle</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>