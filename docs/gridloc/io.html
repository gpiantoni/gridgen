<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gridloc.io API documentation</title>
<meta name="description" content="Functions to input and output data" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gridloc.io</code></h1>
</header>
<section id="section-intro">
<p>Functions to input and output data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to input and output data
&#34;&#34;&#34;
from numpy import (
    array,
    c_,
    cross,
    dtype,
    empty,
    genfromtxt,
    Inf,
    intersect1d,
    isnan,
    loadtxt,
    NaN,
    savetxt,
    unique,
    unravel_index,
    where,
    zeros,
    )
from numpy.linalg import norm
from multiprocessing import Pool
from functools import partial
from pathlib import Path
from textwrap import dedent
from warnings import warn

from nibabel import load as nload
from nibabel.freesurfer import read_geometry
from nibabel.affines import apply_affine

from logging import getLogger
from .construct import make_grid

SLICER_HEADER = &#34;&#34;&#34;# Markups fiducial file version = 4.10
# CoordinateSystem = 0
# columns = id,x,y,z,ow,ox,oy,oz,vis,sel,lock,label,desc,associatedNodeID
&#34;&#34;&#34;

DTYPE = [
    (&#39;name&#39;, &#39;U256&#39;),
    (&#39;x&#39;, &#39;double&#39;),
    (&#39;y&#39;, &#39;double&#39;),
    (&#39;z&#39;, &#39;double&#39;),
    ]
WIRE = &#39;wire&#39;

lg = getLogger(__name__)


def write_grid2d(grid_file, grid2d):
    &#34;&#34;&#34;Write the labels of a 2D grid to file

    Parameters
    ----------
    grid_file : Path
        file to write to (preferred extension .csv)
    grid2d : 2d ndarray
        grid (n_rows, n_columns) with fields (label, pos, norm, done)
    &#34;&#34;&#34;
    with grid_file.open(&#39;w&#39;) as f:
        for row in grid2d[&#39;label&#39;]:
            f.write(&#39;\t&#39;.join(row) + &#39;\n&#39;)
        wires = [WIRE, ] * len(row)
        f.write(&#39;\t&#39;.join(wires))


def read_grid2d(grid_file):
    &#34;&#34;&#34;Read the labels of a 2D grid to file

    Parameters
    ----------
    grid_file : Path
        file to write to (preferred extension .csv)

    Returns
    -------
    grid2d : 2d ndarray
        grid (n_rows, n_columns) with fields (label, pos, norm, done)
    &#34;&#34;&#34;
    labels = []
    with grid_file.open(&#39;r&#39;) as f:
        for row in f.readlines():
            labels.append([x.strip() for x in row.split(&#39;\t&#39;)])

    labels = array(labels)
    grid2d = make_grid(labels.shape[0], labels.shape[1])
    grid2d[&#39;label&#39;] = labels
    return grid2d


def write_ecog2d(ecog_file, ecog2d):
    &#34;&#34;&#34;Write the values of ECoG analysis to file

    Parameters
    ----------
    ecog_file : Path
        file to write to (preferred extension .csv)
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog, good)
    &#34;&#34;&#34;
    savetxt(ecog_file, ecog2d[&#39;ecog&#39;], fmt=&#39;%.8f&#39;, delimiter=&#39;\t&#39;)


def read_ecog2d(ecog_file, grid_file):
    &#34;&#34;&#34;Read the values of ECoG analysis

    Parameters
    ----------
    ecog_file : Path
        file with ecog data (in 2d)
    grid_file : Path
        file with labels (in 2d)

    Returns
    -------
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog)
    &#34;&#34;&#34;
    ecog = loadtxt(ecog_file, delimiter=&#39;\t&#39;)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(ecog.shape, dtype=d_)
    ecog_on_grid[&#39;ecog&#39;] = ecog
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog)
    ecog_on_grid[&#39;label&#39;] = read_grid2d(grid_file)[&#39;label&#39;]

    return ecog_on_grid


def read_ecog2d_matlab(gamma_file, grid_file):
    &#34;&#34;&#34;Read the values of ECoG analysis

    Parameters
    ----------
    ecog_file : Path
        file with ecog data from matlab (&#39;gamma mean&#39;)
    grid_file : Path
        file with labels (in 2d)

    Returns
    -------
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog)
    &#34;&#34;&#34;
    from .matlab.io import read_matlab

    grid2d = read_grid2d(grid_file)
    gamma_mean = read_matlab(gamma_file)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(grid2d.shape, dtype=d_)
    ecog_on_grid[&#39;label&#39;] = grid2d[&#39;label&#39;]
    ecog_on_grid[&#39;ecog&#39;] = gamma_mean.reshape(grid2d.shape, order=&#39;F&#39;)
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog_on_grid[&#39;ecog&#39;])

    return ecog_on_grid


def read_surf(surf_file, ras_shift=None, normals=True):
    &#34;&#34;&#34;Read surface file from freesurfer and compute normals.

    Parameters
    ----------
    surf_file : path
        path to Freesurfer pial file (like lh.pial or rh_smooth.pial)
    ras_shift : (3, ) array
        difference in coordinate system between meshes and MRI volume
    normals : bool
        whether to compute normals (it takes one minute roughly)

    Returns
    -------
    dict with fields
        pos : position of each vertex
        tri : triangles (faces) connection between vertices
        pos_norm : normal for each vertex
        tri_norm : normal for each triangle (face)

    Notes
    -----
    All the normals are set to 1, by definition. This is necessary when computing
    the cross-product in later stages.

    It can handle meshes which have vertices that do not belong to a triangle.
    The normal for a vertex without triangle is NaN

    It&#39;s strongly adviced to use `ras_shift`, so that all the coordinates are
    consistent in MRI volume space.
    &#34;&#34;&#34;
    pos, tri = read_geometry(surf_file)
    if ras_shift is None:
        lg.warning(&#39;`ras_shift` was not passed. Coordinates in the original mesh coordinate systems, not in the MRI volume space&#39;)
    else:
        pos += ras_shift

    surf = {
        &#39;tri&#39;: tri,
        &#39;pos&#39;: pos,
        &#39;tri_norm&#39;: None,
        &#39;pos_norm&#39;: None,
        }

    if not normals:
        return surf

    tris = surf[&#39;pos&#39;][surf[&#39;tri&#39;]]

    surf[&#39;tri_norm&#39;] = cross(tris[:, 1, :] - tris[:, 0, :], tris[:, 2, :] - tris[:, 0, :])
    surf[&#39;tri_norm&#39;] /= norm(surf[&#39;tri_norm&#39;], axis=1)[:, None]

    i_vertices = unique(surf[&#39;tri&#39;])
    with Pool() as p:
        f_compute = partial(_average_normal_per_vertex, tri_norm=surf[&#39;tri_norm&#39;], tri=surf[&#39;tri&#39;])
        vert_norm = p.map(f_compute, i_vertices)

    pos_norm = array(vert_norm)
    pos_norm /= norm(pos_norm, axis=1)[:, None]

    surf[&#39;pos_norm&#39;] = empty(surf[&#39;pos&#39;].shape)
    surf[&#39;pos_norm&#39;].fill(NaN)
    surf[&#39;pos_norm&#39;][i_vertices] = pos_norm

    return surf


def _average_normal_per_vertex(i, tri_norm, tri):
    return tri_norm[(tri == i).any(axis=1)].mean(axis=0)


def export_grid(grid, ras_shift, grid_file, format=None):
    &#34;&#34;&#34;
    Parameters
    ----------
    grid : NxNx2x3 array
        grid with positions and normals
    ras_shift : (3, ) array
        shift between MRI volume and meshes
    grid_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;. If not specified, both of them

    NOTES
    -----
    Note that the positions should be in the coordinate system of the meshes (not
    the coordinate system of the volume MRI)

    TODO
    ----
    There is something wrong with normals (I guess it depends on how Slicer
    imports them)
    &#34;&#34;&#34;
    if format is None:
        for one_format in (&#39;freeview&#39;, &#39;slicer&#39;):
            export_grid(grid, ras_shift, grid_file, one_format)
        return

    labels = grid[&#39;label&#39;].reshape(-1)
    positions = grid[&#39;pos&#39;].reshape(-1, 3) - ras_shift
    normals = grid[&#39;norm&#39;].reshape(-1, 3)

    grid_file = Path(grid_file)

    if format == &#39;slicer&#39;:
        grid_file = grid_file.with_suffix(&#39;.fcsv&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(SLICER_HEADER)
            for i in range(positions.shape[0]):
                f.write(f&#39;vtkMRMLMarkupsFiducialNode_{i:03d},{positions[i, 0]:.3f},{positions[i, 1]:.3f},{positions[i, 2]:.3f},{normals[i, 0]:.3f},{normals[i, 1]:.3f},{normals[i, 2]:.3f},1.000,1,0,1,{labels[i]},,\n&#39;)

    elif format == &#39;freeview&#39;:
        grid_file = grid_file.with_suffix(&#39;.label&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(&#39;#!ascii label  , from subject  vox2ras=TkReg\n&#39;)
            f.write(f&#39;{positions.shape[0]:d}\n&#39;)
            for i in range(positions.shape[0]):
                f.write(f&#39;{-1:d}  {positions[i, 0]:.3f}  {positions[i, 1]:.3f}  { positions[i, 2]:.3f} 1.000\n&#39;)
        warn(&#39;make sure that you select the correct volume (.mgz file) associated with the pial surface in freeview when loading the points&#39;)


def write_tsv(labels, positions, elec_file):
    &#34;&#34;&#34;Write electrode position to tsv

    Parameters
    ----------
    labels : list of str
        electrode labels
    positions : NxNx3 or Nx3 array
        electrode position. Make sure to including ras_shift or not if it&#39;s in
        MRI space or in mesh space.
    elec_file : Path
        path to write to
    &#34;&#34;&#34;
    labels = labels.reshape(-1, order=&#39;F&#39;)
    positions = positions.reshape(-1, 3, order=&#39;F&#39;)

    elec_file = elec_file.with_suffix(&#39;.tsv&#39;)
    with elec_file.open(&#39;w&#39;) as f:
        f.write(&#39;name\tx\ty\tz\n&#39;)
        for i in range(labels.shape[0]):
            f.write(f&#39;{labels[i]}\t{positions[i, 0]:.3f}\t{positions[i, 1]:.3f}\t{positions[i, 2]:.3f}\n&#39;)


def read_surface_ras_shift(T1_path):
    &#34;&#34;&#34;Freesurfer uses two coordinate systems: one for volumes (&#34;RAS&#34;) and
    one for surfaces (&#34;tkReg&#34;, &#34;tkRAS&#34;, and &#34;Surface RAS&#34;).
    To get from surface to volume coordinates, add these numbers.
    To get from volume to surface coordinates, substract these numbers.

    Parameters
    ----------
    T1_path : str
        file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)

    Returns
    -------
    3 array
        offset between volume and surface (tkRAS)
    &#34;&#34;&#34;
    T1 = nload(str(T1_path))

    return T1.header[&#39;Pxyz_c&#39;]


def export_transform(offset, transform_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;Export tkRAS transformation to a transform file.

    Parameters
    ----------
    offset : 3 array
        offset between surface and volume
    transform_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;
    &#34;&#34;&#34;
    assert format == &#39;slicer&#39;

    transform_file = Path(transform_file)

    transform_file = transform_file.with_suffix(&#39;.tfm&#39;)

    # use ITK convertion (&#34;ITK&#39;s convention is to use LPS coordinate system as opposed to RAS coordinate system in Slicer&#34;)
    offset = offset * [-1, -1, 1]

    tfm = &#34;&#34;&#34;\
        #Insight Transform File V1.0
        #Transform 0
        Transform: AffineTransform_double_3_3
        Parameters: 1 0 0 0 1 0 0 0 1 {:.3f} {:.3f} {:.3f}
        FixedParameters: 0 0 0
        &#34;&#34;&#34;.format(*offset)

    with transform_file.open(&#39;w&#39;) as f:
        f.write(dedent(tfm))


def read_volume(volume_file, threshold=-Inf):
    &#34;&#34;&#34;Read 3D volume. You can also apply threshold to the data

    Parameters
    ----------
    volume_file : path
        path to the nifti file
    threshold : float
        only values above this threshold will be included

    Returns
    -------
    ndarray of shape (n_points, ) with fields:
        - pos : 3 floats (specifying the x, y, z position)
        - value : float (actual value at that point)

    Notes
    -----
    Values below the threhold are not included in the output
    &#34;&#34;&#34;
    volume = nload(str(volume_file))
    data = volume.get_data()
    i = data &gt;= threshold

    d_ = dtype([
        (&#39;pos&#39;, &#39;f4&#39;, (3, )),
        (&#39;value&#39;, &#39;f4&#39;),
        ])
    output = zeros(i.sum(), dtype=d_)

    output[&#39;pos&#39;] = apply_affine(volume.affine, array(where(i)).T)
    output[&#39;value&#39;] = data[i]

    return output


def read_elec(grid2d, elec_file):
    &#34;&#34;&#34;Read electrode locations and match them to a grid2d

    Parameters
    ----------
    grid2d : instance of grid2d
        grid2d with labels
    elec_file : path to .mat or .tsv

    Returns
    -------
    instance of grid2d
        where &#39;pos&#39; are taken from elec_file
    &#34;&#34;&#34;
    grid2d = grid2d.copy()  # prevents changing the input file

    if elec_file.suffix == &#39;.mat&#39;:
        from .matlab.io import read_matlab

        xyz = read_matlab(elec_file)
        labels = array([f&#39;chan{x + 1}&#39; for x in range(xyz.shape[0])])

    elif elec_file.suffix == &#39;.tsv&#39;:
        elec = genfromtxt(elec_file, skip_header=1, dtype=DTYPE)
        labels = elec[&#39;name&#39;]
        xyz = c_[elec[&#39;x&#39;], elec[&#39;y&#39;], elec[&#39;z&#39;]]

    i_grid, i_mat = intersect1d(grid2d[&#39;label&#39;], labels, return_indices=True)[1:]
    i = unravel_index(i_grid, grid2d.shape)
    grid2d[&#39;pos&#39;][i] = xyz[i_mat]

    return grid2d


def read_mri(T1_file, dura_file, pial_file, angio_file, angio_threshold):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    ras_shift = read_surface_ras_shift(T1_file)
    lg.debug(f&#39;Reading positions and computing normals of {dura_file}&#39;)
    dura = read_surf(dura_file, ras_shift=ras_shift)
    lg.debug(f&#39;Reading positions of {pial_file}&#39;)
    pial = read_surf(pial_file, normals=False, ras_shift=ras_shift)

    if angio_file is not None and angio_file:
        lg.debug(f&#39;Reading angiogram from {angio_file} and thresholding at {angio_threshold}&#39;)
        angio = read_volume(angio_file, angio_threshold)
        angio[&#39;value&#39;] = 1  # set the value of each voxel above threshold to 1
    else:
        angio = None

    out = {
        &#34;ras_shift&#34;: ras_shift,
        &#34;pial&#34;: pial,
        &#34;dura&#34;: dura,
        &#34;angio&#34;: angio,
        }
    return out</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gridloc.io.export_grid"><code class="name flex">
<span>def <span class="ident">export_grid</span></span>(<span>grid, ras_shift, grid_file, format=None)</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>NxNx2x3 array</code></dt>
<dd>grid with positions and normals</dd>
<dt><strong><code>ras_shift</code></strong> :&ensp;<code>(3, ) array</code></dt>
<dd>shift between MRI volume and meshes</dd>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>str</code></dt>
<dd>file name to export to (extension is based on format)</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>'slicer' or 'freeview'. If not specified, both of them</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Note that the positions should be in the coordinate system of the meshes (not
the coordinate system of the volume MRI)</p>
<h2 id="todo">Todo</h2>
<p>There is something wrong with normals (I guess it depends on how Slicer
imports them)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_grid(grid, ras_shift, grid_file, format=None):
    &#34;&#34;&#34;
    Parameters
    ----------
    grid : NxNx2x3 array
        grid with positions and normals
    ras_shift : (3, ) array
        shift between MRI volume and meshes
    grid_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;. If not specified, both of them

    NOTES
    -----
    Note that the positions should be in the coordinate system of the meshes (not
    the coordinate system of the volume MRI)

    TODO
    ----
    There is something wrong with normals (I guess it depends on how Slicer
    imports them)
    &#34;&#34;&#34;
    if format is None:
        for one_format in (&#39;freeview&#39;, &#39;slicer&#39;):
            export_grid(grid, ras_shift, grid_file, one_format)
        return

    labels = grid[&#39;label&#39;].reshape(-1)
    positions = grid[&#39;pos&#39;].reshape(-1, 3) - ras_shift
    normals = grid[&#39;norm&#39;].reshape(-1, 3)

    grid_file = Path(grid_file)

    if format == &#39;slicer&#39;:
        grid_file = grid_file.with_suffix(&#39;.fcsv&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(SLICER_HEADER)
            for i in range(positions.shape[0]):
                f.write(f&#39;vtkMRMLMarkupsFiducialNode_{i:03d},{positions[i, 0]:.3f},{positions[i, 1]:.3f},{positions[i, 2]:.3f},{normals[i, 0]:.3f},{normals[i, 1]:.3f},{normals[i, 2]:.3f},1.000,1,0,1,{labels[i]},,\n&#39;)

    elif format == &#39;freeview&#39;:
        grid_file = grid_file.with_suffix(&#39;.label&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(&#39;#!ascii label  , from subject  vox2ras=TkReg\n&#39;)
            f.write(f&#39;{positions.shape[0]:d}\n&#39;)
            for i in range(positions.shape[0]):
                f.write(f&#39;{-1:d}  {positions[i, 0]:.3f}  {positions[i, 1]:.3f}  { positions[i, 2]:.3f} 1.000\n&#39;)
        warn(&#39;make sure that you select the correct volume (.mgz file) associated with the pial surface in freeview when loading the points&#39;)</code></pre>
</details>
</dd>
<dt id="gridloc.io.export_transform"><code class="name flex">
<span>def <span class="ident">export_transform</span></span>(<span>offset, transform_file, format='slicer')</span>
</code></dt>
<dd>
<div class="desc"><p>Export tkRAS transformation to a transform file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>3 array</code></dt>
<dd>offset between surface and volume</dd>
<dt><strong><code>transform_file</code></strong> :&ensp;<code>str</code></dt>
<dd>file name to export to (extension is based on format)</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>'slicer' or 'freeview'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_transform(offset, transform_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;Export tkRAS transformation to a transform file.

    Parameters
    ----------
    offset : 3 array
        offset between surface and volume
    transform_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;
    &#34;&#34;&#34;
    assert format == &#39;slicer&#39;

    transform_file = Path(transform_file)

    transform_file = transform_file.with_suffix(&#39;.tfm&#39;)

    # use ITK convertion (&#34;ITK&#39;s convention is to use LPS coordinate system as opposed to RAS coordinate system in Slicer&#34;)
    offset = offset * [-1, -1, 1]

    tfm = &#34;&#34;&#34;\
        #Insight Transform File V1.0
        #Transform 0
        Transform: AffineTransform_double_3_3
        Parameters: 1 0 0 0 1 0 0 0 1 {:.3f} {:.3f} {:.3f}
        FixedParameters: 0 0 0
        &#34;&#34;&#34;.format(*offset)

    with transform_file.open(&#39;w&#39;) as f:
        f.write(dedent(tfm))</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_ecog2d"><code class="name flex">
<span>def <span class="ident">read_ecog2d</span></span>(<span>ecog_file, grid_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the values of ECoG analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecog_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file with ecog data (in 2d)</dd>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file with labels (in 2d)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ecog2d</code></strong> :&ensp;<code>2d ndarray</code></dt>
<dd>ecog (n_rows, n_columns) with fields (label, ecog)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_ecog2d(ecog_file, grid_file):
    &#34;&#34;&#34;Read the values of ECoG analysis

    Parameters
    ----------
    ecog_file : Path
        file with ecog data (in 2d)
    grid_file : Path
        file with labels (in 2d)

    Returns
    -------
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog)
    &#34;&#34;&#34;
    ecog = loadtxt(ecog_file, delimiter=&#39;\t&#39;)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(ecog.shape, dtype=d_)
    ecog_on_grid[&#39;ecog&#39;] = ecog
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog)
    ecog_on_grid[&#39;label&#39;] = read_grid2d(grid_file)[&#39;label&#39;]

    return ecog_on_grid</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_ecog2d_matlab"><code class="name flex">
<span>def <span class="ident">read_ecog2d_matlab</span></span>(<span>gamma_file, grid_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the values of ECoG analysis</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecog_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file with ecog data from matlab ('gamma mean')</dd>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file with labels (in 2d)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ecog2d</code></strong> :&ensp;<code>2d ndarray</code></dt>
<dd>ecog (n_rows, n_columns) with fields (label, ecog)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_ecog2d_matlab(gamma_file, grid_file):
    &#34;&#34;&#34;Read the values of ECoG analysis

    Parameters
    ----------
    ecog_file : Path
        file with ecog data from matlab (&#39;gamma mean&#39;)
    grid_file : Path
        file with labels (in 2d)

    Returns
    -------
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog)
    &#34;&#34;&#34;
    from .matlab.io import read_matlab

    grid2d = read_grid2d(grid_file)
    gamma_mean = read_matlab(gamma_file)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(grid2d.shape, dtype=d_)
    ecog_on_grid[&#39;label&#39;] = grid2d[&#39;label&#39;]
    ecog_on_grid[&#39;ecog&#39;] = gamma_mean.reshape(grid2d.shape, order=&#39;F&#39;)
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog_on_grid[&#39;ecog&#39;])

    return ecog_on_grid</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_elec"><code class="name flex">
<span>def <span class="ident">read_elec</span></span>(<span>grid2d, elec_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Read electrode locations and match them to a grid2d</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid2d</code></strong> :&ensp;<code>instance</code> of <code>grid2d</code></dt>
<dd>grid2d with labels</dd>
<dt><strong><code>elec_file</code></strong> :&ensp;<code>path to .mat</code> or <code>.tsv</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>instance</code> of <code>grid2d</code></dt>
<dd>where 'pos' are taken from elec_file</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_elec(grid2d, elec_file):
    &#34;&#34;&#34;Read electrode locations and match them to a grid2d

    Parameters
    ----------
    grid2d : instance of grid2d
        grid2d with labels
    elec_file : path to .mat or .tsv

    Returns
    -------
    instance of grid2d
        where &#39;pos&#39; are taken from elec_file
    &#34;&#34;&#34;
    grid2d = grid2d.copy()  # prevents changing the input file

    if elec_file.suffix == &#39;.mat&#39;:
        from .matlab.io import read_matlab

        xyz = read_matlab(elec_file)
        labels = array([f&#39;chan{x + 1}&#39; for x in range(xyz.shape[0])])

    elif elec_file.suffix == &#39;.tsv&#39;:
        elec = genfromtxt(elec_file, skip_header=1, dtype=DTYPE)
        labels = elec[&#39;name&#39;]
        xyz = c_[elec[&#39;x&#39;], elec[&#39;y&#39;], elec[&#39;z&#39;]]

    i_grid, i_mat = intersect1d(grid2d[&#39;label&#39;], labels, return_indices=True)[1:]
    i = unravel_index(i_grid, grid2d.shape)
    grid2d[&#39;pos&#39;][i] = xyz[i_mat]

    return grid2d</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_grid2d"><code class="name flex">
<span>def <span class="ident">read_grid2d</span></span>(<span>grid_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the labels of a 2D grid to file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file to write to (preferred extension .csv)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>grid2d</code></strong> :&ensp;<code>2d ndarray</code></dt>
<dd>grid (n_rows, n_columns) with fields (label, pos, norm, done)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_grid2d(grid_file):
    &#34;&#34;&#34;Read the labels of a 2D grid to file

    Parameters
    ----------
    grid_file : Path
        file to write to (preferred extension .csv)

    Returns
    -------
    grid2d : 2d ndarray
        grid (n_rows, n_columns) with fields (label, pos, norm, done)
    &#34;&#34;&#34;
    labels = []
    with grid_file.open(&#39;r&#39;) as f:
        for row in f.readlines():
            labels.append([x.strip() for x in row.split(&#39;\t&#39;)])

    labels = array(labels)
    grid2d = make_grid(labels.shape[0], labels.shape[1])
    grid2d[&#39;label&#39;] = labels
    return grid2d</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_mri"><code class="name flex">
<span>def <span class="ident">read_mri</span></span>(<span>T1_file, dura_file, pial_file, angio_file, angio_threshold)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_mri(T1_file, dura_file, pial_file, angio_file, angio_threshold):
    &#34;&#34;&#34;
    &#34;&#34;&#34;
    ras_shift = read_surface_ras_shift(T1_file)
    lg.debug(f&#39;Reading positions and computing normals of {dura_file}&#39;)
    dura = read_surf(dura_file, ras_shift=ras_shift)
    lg.debug(f&#39;Reading positions of {pial_file}&#39;)
    pial = read_surf(pial_file, normals=False, ras_shift=ras_shift)

    if angio_file is not None and angio_file:
        lg.debug(f&#39;Reading angiogram from {angio_file} and thresholding at {angio_threshold}&#39;)
        angio = read_volume(angio_file, angio_threshold)
        angio[&#39;value&#39;] = 1  # set the value of each voxel above threshold to 1
    else:
        angio = None

    out = {
        &#34;ras_shift&#34;: ras_shift,
        &#34;pial&#34;: pial,
        &#34;dura&#34;: dura,
        &#34;angio&#34;: angio,
        }
    return out</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_surf"><code class="name flex">
<span>def <span class="ident">read_surf</span></span>(<span>surf_file, ras_shift=None, normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Read surface file from freesurfer and compute normals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>surf_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to Freesurfer pial file (like lh.pial or rh_smooth.pial)</dd>
<dt><strong><code>ras_shift</code></strong> :&ensp;<code>(3, ) array</code></dt>
<dd>difference in coordinate system between meshes and MRI volume</dd>
<dt><strong><code>normals</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to compute normals (it takes one minute roughly)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict with fields</code></dt>
<dd>pos : position of each vertex
tri : triangles (faces) connection between vertices
pos_norm : normal for each vertex
tri_norm : normal for each triangle (face)</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>All the normals are set to 1, by definition. This is necessary when computing
the cross-product in later stages.</p>
<p>It can handle meshes which have vertices that do not belong to a triangle.
The normal for a vertex without triangle is NaN</p>
<p>It's strongly adviced to use <code>ras_shift</code>, so that all the coordinates are
consistent in MRI volume space.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_surf(surf_file, ras_shift=None, normals=True):
    &#34;&#34;&#34;Read surface file from freesurfer and compute normals.

    Parameters
    ----------
    surf_file : path
        path to Freesurfer pial file (like lh.pial or rh_smooth.pial)
    ras_shift : (3, ) array
        difference in coordinate system between meshes and MRI volume
    normals : bool
        whether to compute normals (it takes one minute roughly)

    Returns
    -------
    dict with fields
        pos : position of each vertex
        tri : triangles (faces) connection between vertices
        pos_norm : normal for each vertex
        tri_norm : normal for each triangle (face)

    Notes
    -----
    All the normals are set to 1, by definition. This is necessary when computing
    the cross-product in later stages.

    It can handle meshes which have vertices that do not belong to a triangle.
    The normal for a vertex without triangle is NaN

    It&#39;s strongly adviced to use `ras_shift`, so that all the coordinates are
    consistent in MRI volume space.
    &#34;&#34;&#34;
    pos, tri = read_geometry(surf_file)
    if ras_shift is None:
        lg.warning(&#39;`ras_shift` was not passed. Coordinates in the original mesh coordinate systems, not in the MRI volume space&#39;)
    else:
        pos += ras_shift

    surf = {
        &#39;tri&#39;: tri,
        &#39;pos&#39;: pos,
        &#39;tri_norm&#39;: None,
        &#39;pos_norm&#39;: None,
        }

    if not normals:
        return surf

    tris = surf[&#39;pos&#39;][surf[&#39;tri&#39;]]

    surf[&#39;tri_norm&#39;] = cross(tris[:, 1, :] - tris[:, 0, :], tris[:, 2, :] - tris[:, 0, :])
    surf[&#39;tri_norm&#39;] /= norm(surf[&#39;tri_norm&#39;], axis=1)[:, None]

    i_vertices = unique(surf[&#39;tri&#39;])
    with Pool() as p:
        f_compute = partial(_average_normal_per_vertex, tri_norm=surf[&#39;tri_norm&#39;], tri=surf[&#39;tri&#39;])
        vert_norm = p.map(f_compute, i_vertices)

    pos_norm = array(vert_norm)
    pos_norm /= norm(pos_norm, axis=1)[:, None]

    surf[&#39;pos_norm&#39;] = empty(surf[&#39;pos&#39;].shape)
    surf[&#39;pos_norm&#39;].fill(NaN)
    surf[&#39;pos_norm&#39;][i_vertices] = pos_norm

    return surf</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_surface_ras_shift"><code class="name flex">
<span>def <span class="ident">read_surface_ras_shift</span></span>(<span>T1_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Freesurfer uses two coordinate systems: one for volumes ("RAS") and
one for surfaces ("tkReg", "tkRAS", and "Surface RAS").
To get from surface to volume coordinates, add these numbers.
To get from volume to surface coordinates, substract these numbers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T1_path</code></strong> :&ensp;<code>str</code></dt>
<dd>file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>3 array</code></dt>
<dd>offset between volume and surface (tkRAS)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_surface_ras_shift(T1_path):
    &#34;&#34;&#34;Freesurfer uses two coordinate systems: one for volumes (&#34;RAS&#34;) and
    one for surfaces (&#34;tkReg&#34;, &#34;tkRAS&#34;, and &#34;Surface RAS&#34;).
    To get from surface to volume coordinates, add these numbers.
    To get from volume to surface coordinates, substract these numbers.

    Parameters
    ----------
    T1_path : str
        file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)

    Returns
    -------
    3 array
        offset between volume and surface (tkRAS)
    &#34;&#34;&#34;
    T1 = nload(str(T1_path))

    return T1.header[&#39;Pxyz_c&#39;]</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_volume"><code class="name flex">
<span>def <span class="ident">read_volume</span></span>(<span>volume_file, threshold=-inf)</span>
</code></dt>
<dd>
<div class="desc"><p>Read 3D volume. You can also apply threshold to the data</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>volume_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to the nifti file</dd>
<dt><strong><code>threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>only values above this threshold will be included</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ndarray</code> of <code>shape (n_points, ) with fields:</code></dt>
<dd>
<ul>
<li>pos : 3 floats (specifying the x, y, z position)</li>
<li>value : float (actual value at that point)</li>
</ul>
</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>Values below the threhold are not included in the output</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_volume(volume_file, threshold=-Inf):
    &#34;&#34;&#34;Read 3D volume. You can also apply threshold to the data

    Parameters
    ----------
    volume_file : path
        path to the nifti file
    threshold : float
        only values above this threshold will be included

    Returns
    -------
    ndarray of shape (n_points, ) with fields:
        - pos : 3 floats (specifying the x, y, z position)
        - value : float (actual value at that point)

    Notes
    -----
    Values below the threhold are not included in the output
    &#34;&#34;&#34;
    volume = nload(str(volume_file))
    data = volume.get_data()
    i = data &gt;= threshold

    d_ = dtype([
        (&#39;pos&#39;, &#39;f4&#39;, (3, )),
        (&#39;value&#39;, &#39;f4&#39;),
        ])
    output = zeros(i.sum(), dtype=d_)

    output[&#39;pos&#39;] = apply_affine(volume.affine, array(where(i)).T)
    output[&#39;value&#39;] = data[i]

    return output</code></pre>
</details>
</dd>
<dt id="gridloc.io.write_ecog2d"><code class="name flex">
<span>def <span class="ident">write_ecog2d</span></span>(<span>ecog_file, ecog2d)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the values of ECoG analysis to file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ecog_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file to write to (preferred extension .csv)</dd>
<dt><strong><code>ecog2d</code></strong> :&ensp;<code>2d ndarray</code></dt>
<dd>ecog (n_rows, n_columns) with fields (label, ecog, good)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_ecog2d(ecog_file, ecog2d):
    &#34;&#34;&#34;Write the values of ECoG analysis to file

    Parameters
    ----------
    ecog_file : Path
        file to write to (preferred extension .csv)
    ecog2d : 2d ndarray
        ecog (n_rows, n_columns) with fields (label, ecog, good)
    &#34;&#34;&#34;
    savetxt(ecog_file, ecog2d[&#39;ecog&#39;], fmt=&#39;%.8f&#39;, delimiter=&#39;\t&#39;)</code></pre>
</details>
</dd>
<dt id="gridloc.io.write_grid2d"><code class="name flex">
<span>def <span class="ident">write_grid2d</span></span>(<span>grid_file, grid2d)</span>
</code></dt>
<dd>
<div class="desc"><p>Write the labels of a 2D grid to file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>file to write to (preferred extension .csv)</dd>
<dt><strong><code>grid2d</code></strong> :&ensp;<code>2d ndarray</code></dt>
<dd>grid (n_rows, n_columns) with fields (label, pos, norm, done)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_grid2d(grid_file, grid2d):
    &#34;&#34;&#34;Write the labels of a 2D grid to file

    Parameters
    ----------
    grid_file : Path
        file to write to (preferred extension .csv)
    grid2d : 2d ndarray
        grid (n_rows, n_columns) with fields (label, pos, norm, done)
    &#34;&#34;&#34;
    with grid_file.open(&#39;w&#39;) as f:
        for row in grid2d[&#39;label&#39;]:
            f.write(&#39;\t&#39;.join(row) + &#39;\n&#39;)
        wires = [WIRE, ] * len(row)
        f.write(&#39;\t&#39;.join(wires))</code></pre>
</details>
</dd>
<dt id="gridloc.io.write_tsv"><code class="name flex">
<span>def <span class="ident">write_tsv</span></span>(<span>labels, positions, elec_file)</span>
</code></dt>
<dd>
<div class="desc"><p>Write electrode position to tsv</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>labels</code></strong> :&ensp;<code>list</code> of <code>str</code></dt>
<dd>electrode labels</dd>
<dt><strong><code>positions</code></strong> :&ensp;<code>NxNx3</code> or <code>Nx3 array</code></dt>
<dd>electrode position. Make sure to including ras_shift or not if it's in
MRI space or in mesh space.</dd>
<dt><strong><code>elec_file</code></strong> :&ensp;<code>Path</code></dt>
<dd>path to write to</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_tsv(labels, positions, elec_file):
    &#34;&#34;&#34;Write electrode position to tsv

    Parameters
    ----------
    labels : list of str
        electrode labels
    positions : NxNx3 or Nx3 array
        electrode position. Make sure to including ras_shift or not if it&#39;s in
        MRI space or in mesh space.
    elec_file : Path
        path to write to
    &#34;&#34;&#34;
    labels = labels.reshape(-1, order=&#39;F&#39;)
    positions = positions.reshape(-1, 3, order=&#39;F&#39;)

    elec_file = elec_file.with_suffix(&#39;.tsv&#39;)
    with elec_file.open(&#39;w&#39;) as f:
        f.write(&#39;name\tx\ty\tz\n&#39;)
        for i in range(labels.shape[0]):
            f.write(f&#39;{labels[i]}\t{positions[i, 0]:.3f}\t{positions[i, 1]:.3f}\t{positions[i, 2]:.3f}\n&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gridloc" href="index.html">gridloc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gridloc.io.export_grid" href="#gridloc.io.export_grid">export_grid</a></code></li>
<li><code><a title="gridloc.io.export_transform" href="#gridloc.io.export_transform">export_transform</a></code></li>
<li><code><a title="gridloc.io.read_ecog2d" href="#gridloc.io.read_ecog2d">read_ecog2d</a></code></li>
<li><code><a title="gridloc.io.read_ecog2d_matlab" href="#gridloc.io.read_ecog2d_matlab">read_ecog2d_matlab</a></code></li>
<li><code><a title="gridloc.io.read_elec" href="#gridloc.io.read_elec">read_elec</a></code></li>
<li><code><a title="gridloc.io.read_grid2d" href="#gridloc.io.read_grid2d">read_grid2d</a></code></li>
<li><code><a title="gridloc.io.read_mri" href="#gridloc.io.read_mri">read_mri</a></code></li>
<li><code><a title="gridloc.io.read_surf" href="#gridloc.io.read_surf">read_surf</a></code></li>
<li><code><a title="gridloc.io.read_surface_ras_shift" href="#gridloc.io.read_surface_ras_shift">read_surface_ras_shift</a></code></li>
<li><code><a title="gridloc.io.read_volume" href="#gridloc.io.read_volume">read_volume</a></code></li>
<li><code><a title="gridloc.io.write_ecog2d" href="#gridloc.io.write_ecog2d">write_ecog2d</a></code></li>
<li><code><a title="gridloc.io.write_grid2d" href="#gridloc.io.write_grid2d">write_grid2d</a></code></li>
<li><code><a title="gridloc.io.write_tsv" href="#gridloc.io.write_tsv">write_tsv</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>