<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gridloc.io API documentation</title>
<meta name="description" content="Functions to input and output data" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gridloc.io</code></h1>
</header>
<section id="section-intro">
<p>Functions to input and output data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to input and output data
&#34;&#34;&#34;
from numpy import cross, array, savetxt, isnan, zeros, dtype, loadtxt, where, Inf
from numpy.linalg import norm
from multiprocessing import Pool
from functools import partial
from pathlib import Path
from textwrap import dedent
from warnings import warn

from nibabel import load as nload
from nibabel.freesurfer import read_geometry
from nibabel.affines import apply_affine

from logging import getLogger
from .construct import make_grid

SLICER_HEADER = &#34;&#34;&#34;# Markups fiducial file version = 4.10
# CoordinateSystem = 0
# columns = id,x,y,z,ow,ox,oy,oz,vis,sel,lock,label,desc,associatedNodeID
&#34;&#34;&#34;

lg = getLogger(__name__)

def write_grid2d(grid_file, grid2d):
    with grid_file.open(&#39;w&#39;) as f:
        for row in grid2d[&#39;label&#39;]:
            f.write(&#39;\t&#39;.join(row) + &#39;\n&#39;)


def read_grid2d(grid_file):
    labels = []
    with grid_file.open(&#39;r&#39;) as f:
        for row in f.readlines():
            labels.append([x.strip() for x in row.split(&#39;\t&#39;)])

    labels = array(labels)
    grid2d = make_grid(labels.shape[0], labels.shape[1])
    grid2d[&#39;label&#39;] = labels
    return grid2d


def write_ecog2d(ecog_file, ecog2d):
    savetxt(ecog_file, ecog2d[&#39;ecog&#39;], fmt=&#39;%.8f&#39;, delimiter=&#39;\t&#39;)


def read_ecog2d(ecog_file, grid_file):

    ecog = loadtxt(ecog_file, delimiter=&#39;\t&#39;)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(ecog.shape, dtype=d_)
    ecog_on_grid[&#39;ecog&#39;] = ecog
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog)
    ecog_on_grid[&#39;label&#39;] = read_grid2d(grid_file)[&#39;label&#39;]

    return ecog_on_grid


def read_surf(surf_file, normals=True):
    &#34;&#34;&#34;Read surface file from freesurfer and compute normals.

    Parameters
    ----------
    surf_file : path
        path to Freesurfer pial file (like lh.pial or rh_smooth.pial)
    normals : bool
        whether to compute normals (it takes one minute roughly)

    Returns
    -------
    dict with fields
        pos : position of each vertex
        tri : triangles (faces) connection between vertices
        pos_norm : normal for each vertex
        tri_norm : normal for each triangle (face)

    Notes
    -----
    All the normals are set to 1, by definition. This is necessary when computing
    the cross-product in later stages.
    &#34;&#34;&#34;
    pos, tri = read_geometry(surf_file)
    surf = {
        &#39;tri&#39;: tri,
        &#39;pos&#39;: pos,
        &#39;tri_norm&#39;: None,
        &#39;pos_norm&#39;: None,
        }

    tris = surf[&#39;pos&#39;][surf[&#39;tri&#39;]]

    if not normals:
        return surf

    surf[&#39;tri_norm&#39;] = cross(tris[:, 1, :] - tris[:, 0, :], tris[:, 2, :] - tris[:, 0, :])
    surf[&#39;tri_norm&#39;] /= norm(surf[&#39;tri_norm&#39;], axis=1)[:, None]

    with Pool() as p:
        f_compute = partial(_average_normal_per_vertex, tri_norm=surf[&#39;tri_norm&#39;], tri=surf[&#39;tri&#39;])
        vert_norm = p.map(f_compute, range(surf[&#39;pos&#39;].shape[0]))

    surf[&#39;pos_norm&#39;] = array(vert_norm)
    surf[&#39;pos_norm&#39;] /= norm(surf[&#39;pos_norm&#39;], axis=1)[:, None]

    return surf


def _average_normal_per_vertex(i, tri_norm, tri):
    return tri_norm[(tri == i).any(axis=1)].mean(axis=0)


def export_grid(grid, grid_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;
    Parameters
    ----------
    grid : NxNx2x3 array
        grid with positions and normals
    grid_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;

    TODO
    ----
    There is something wrong with normals (I guess it depends on how Slicer
    imports them)
    &#34;&#34;&#34;
    labels = grid[&#39;label&#39;].reshape(-1)
    positions = grid[&#39;pos&#39;].reshape(-1, 3)
    normals = grid[&#39;norm&#39;].reshape(-1, 3)

    grid_file = Path(grid_file)

    if format == &#39;slicer&#39;:
        grid_file = grid_file.with_suffix(&#39;.fcsv&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(SLICER_HEADER)
            for i in range(positions.shape[0]):
                f.write(f&#39;vtkMRMLMarkupsFiducialNode_{i:03d},{positions[i, 0]:.3f},{positions[i, 1]:.3f},{positions[i, 2]:.3f},{normals[i, 0]:.3f},{normals[i, 1]:.3f},{normals[i, 2]:.3f},1.000,1,0,1,{labels[i]},,\n&#39;)

    elif format == &#39;freeview&#39;:
        grid_file = grid_file.with_suffix(&#39;.label&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(&#39;#!ascii label  , from subject  vox2ras=TkReg\n&#39;)
            f.write(f&#39;{positions.shape[0]:d}\n&#39;)
            for i in range(positions.shape[0]):
                f.write(f&#39;{-1:d}  {positions[i, 0]:.3f}  {positions[i, 1]:.3f}  { positions[i, 2]:.3f} 1.000\n&#39;)
        warn(&#39;make sure that you select the correct volume (.mgz file) associated with the pial surface in freeview when loading the points&#39;)


def read_surface_ras_shift(T1_path):
    &#34;&#34;&#34;Freesurfer uses two coordinate systems: one for volumes (&#34;RAS&#34;) and
    one for surfaces (&#34;tkReg&#34;, &#34;tkRAS&#34;, and &#34;Surface RAS&#34;).
    To get from surface to volume coordinates, add these numbers.
    To get from volume to surface coordinates, substract these numbers.

    Parameters
    ----------
    T1_path : str
        file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)

    Returns
    -------
    3 array
        offset between volume and surface (tkRAS)
    &#34;&#34;&#34;
    T1 = nload(str(T1_path))

    return T1.header[&#39;Pxyz_c&#39;]


def export_transform(offset, transform_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;Export tkRAS transformation to a transform file.

    Parameters
    ----------
    offset : 3 array
        offset between surface and volume
    transform_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;
    &#34;&#34;&#34;
    assert format == &#39;slicer&#39;

    transform_file = Path(transform_file)

    transform_file = transform_file.with_suffix(&#39;.tfm&#39;)

    # use ITK convertion (&#34;ITK&#39;s convention is to use LPS coordinate system as opposed to RAS coordinate system in Slicer&#34;)
    offset = offset * [-1, -1, 1]

    tfm = &#34;&#34;&#34;\
        #Insight Transform File V1.0
        #Transform 0
        Transform: AffineTransform_double_3_3
        Parameters: 1 0 0 0 1 0 0 0 1 {:.3f} {:.3f} {:.3f}
        FixedParameters: 0 0 0
        &#34;&#34;&#34;.format(*offset)

    with transform_file.open(&#39;w&#39;) as f:
        f.write(dedent(tfm))


def read_volume(volume_file, threshold=-Inf):
    volume = nload(str(volume_file))
    data = volume.get_data()
    i = data &gt;= threshold

    d_ = dtype([
        (&#39;pos&#39;, &#39;f4&#39;, (3, )),
        (&#39;value&#39;, &#39;f4&#39;),
        ])
    output = zeros(i.sum(), dtype=d_)

    output[&#39;pos&#39;] = apply_affine(volume.affine, array(where(i)).T)
    output[&#39;value&#39;] = data[i]

    return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gridloc.io.export_grid"><code class="name flex">
<span>def <span class="ident">export_grid</span></span>(<span>grid, grid_file, format='slicer')</span>
</code></dt>
<dd>
<div class="desc"><h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>grid</code></strong> :&ensp;<code>NxNx2x3 array</code></dt>
<dd>grid with positions and normals</dd>
<dt><strong><code>grid_file</code></strong> :&ensp;<code>str</code></dt>
<dd>file name to export to (extension is based on format)</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>'slicer' or 'freeview'</dd>
</dl>
<h2 id="todo">Todo</h2>
<p>There is something wrong with normals (I guess it depends on how Slicer
imports them)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_grid(grid, grid_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;
    Parameters
    ----------
    grid : NxNx2x3 array
        grid with positions and normals
    grid_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;

    TODO
    ----
    There is something wrong with normals (I guess it depends on how Slicer
    imports them)
    &#34;&#34;&#34;
    labels = grid[&#39;label&#39;].reshape(-1)
    positions = grid[&#39;pos&#39;].reshape(-1, 3)
    normals = grid[&#39;norm&#39;].reshape(-1, 3)

    grid_file = Path(grid_file)

    if format == &#39;slicer&#39;:
        grid_file = grid_file.with_suffix(&#39;.fcsv&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(SLICER_HEADER)
            for i in range(positions.shape[0]):
                f.write(f&#39;vtkMRMLMarkupsFiducialNode_{i:03d},{positions[i, 0]:.3f},{positions[i, 1]:.3f},{positions[i, 2]:.3f},{normals[i, 0]:.3f},{normals[i, 1]:.3f},{normals[i, 2]:.3f},1.000,1,0,1,{labels[i]},,\n&#39;)

    elif format == &#39;freeview&#39;:
        grid_file = grid_file.with_suffix(&#39;.label&#39;)

        with grid_file.open(&#39;w&#39;) as f:
            f.write(&#39;#!ascii label  , from subject  vox2ras=TkReg\n&#39;)
            f.write(f&#39;{positions.shape[0]:d}\n&#39;)
            for i in range(positions.shape[0]):
                f.write(f&#39;{-1:d}  {positions[i, 0]:.3f}  {positions[i, 1]:.3f}  { positions[i, 2]:.3f} 1.000\n&#39;)
        warn(&#39;make sure that you select the correct volume (.mgz file) associated with the pial surface in freeview when loading the points&#39;)</code></pre>
</details>
</dd>
<dt id="gridloc.io.export_transform"><code class="name flex">
<span>def <span class="ident">export_transform</span></span>(<span>offset, transform_file, format='slicer')</span>
</code></dt>
<dd>
<div class="desc"><p>Export tkRAS transformation to a transform file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>offset</code></strong> :&ensp;<code>3 array</code></dt>
<dd>offset between surface and volume</dd>
<dt><strong><code>transform_file</code></strong> :&ensp;<code>str</code></dt>
<dd>file name to export to (extension is based on format)</dd>
<dt><strong><code>format</code></strong> :&ensp;<code>str</code></dt>
<dd>'slicer' or 'freeview'</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def export_transform(offset, transform_file, format=&#39;slicer&#39;):
    &#34;&#34;&#34;Export tkRAS transformation to a transform file.

    Parameters
    ----------
    offset : 3 array
        offset between surface and volume
    transform_file : str
        file name to export to (extension is based on format)
    format : str
        &#39;slicer&#39; or &#39;freeview&#39;
    &#34;&#34;&#34;
    assert format == &#39;slicer&#39;

    transform_file = Path(transform_file)

    transform_file = transform_file.with_suffix(&#39;.tfm&#39;)

    # use ITK convertion (&#34;ITK&#39;s convention is to use LPS coordinate system as opposed to RAS coordinate system in Slicer&#34;)
    offset = offset * [-1, -1, 1]

    tfm = &#34;&#34;&#34;\
        #Insight Transform File V1.0
        #Transform 0
        Transform: AffineTransform_double_3_3
        Parameters: 1 0 0 0 1 0 0 0 1 {:.3f} {:.3f} {:.3f}
        FixedParameters: 0 0 0
        &#34;&#34;&#34;.format(*offset)

    with transform_file.open(&#39;w&#39;) as f:
        f.write(dedent(tfm))</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_ecog2d"><code class="name flex">
<span>def <span class="ident">read_ecog2d</span></span>(<span>ecog_file, grid_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_ecog2d(ecog_file, grid_file):

    ecog = loadtxt(ecog_file, delimiter=&#39;\t&#39;)

    d_ = dtype([
        (&#39;label&#39;, &#39;&lt;U256&#39;),
        (&#39;ecog&#39;, &#39;f8&#39;),
        (&#39;good&#39;, &#39;bool&#39;),
        ])
    ecog_on_grid = zeros(ecog.shape, dtype=d_)
    ecog_on_grid[&#39;ecog&#39;] = ecog
    ecog_on_grid[&#39;good&#39;] = ~isnan(ecog)
    ecog_on_grid[&#39;label&#39;] = read_grid2d(grid_file)[&#39;label&#39;]

    return ecog_on_grid</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_grid2d"><code class="name flex">
<span>def <span class="ident">read_grid2d</span></span>(<span>grid_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_grid2d(grid_file):
    labels = []
    with grid_file.open(&#39;r&#39;) as f:
        for row in f.readlines():
            labels.append([x.strip() for x in row.split(&#39;\t&#39;)])

    labels = array(labels)
    grid2d = make_grid(labels.shape[0], labels.shape[1])
    grid2d[&#39;label&#39;] = labels
    return grid2d</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_surf"><code class="name flex">
<span>def <span class="ident">read_surf</span></span>(<span>surf_file, normals=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Read surface file from freesurfer and compute normals.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>surf_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to Freesurfer pial file (like lh.pial or rh_smooth.pial)</dd>
<dt><strong><code>normals</code></strong> :&ensp;<code>bool</code></dt>
<dd>whether to compute normals (it takes one minute roughly)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict with fields</code></dt>
<dd>pos : position of each vertex
tri : triangles (faces) connection between vertices
pos_norm : normal for each vertex
tri_norm : normal for each triangle (face)</dd>
</dl>
<h2 id="notes">Notes</h2>
<p>All the normals are set to 1, by definition. This is necessary when computing
the cross-product in later stages.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_surf(surf_file, normals=True):
    &#34;&#34;&#34;Read surface file from freesurfer and compute normals.

    Parameters
    ----------
    surf_file : path
        path to Freesurfer pial file (like lh.pial or rh_smooth.pial)
    normals : bool
        whether to compute normals (it takes one minute roughly)

    Returns
    -------
    dict with fields
        pos : position of each vertex
        tri : triangles (faces) connection between vertices
        pos_norm : normal for each vertex
        tri_norm : normal for each triangle (face)

    Notes
    -----
    All the normals are set to 1, by definition. This is necessary when computing
    the cross-product in later stages.
    &#34;&#34;&#34;
    pos, tri = read_geometry(surf_file)
    surf = {
        &#39;tri&#39;: tri,
        &#39;pos&#39;: pos,
        &#39;tri_norm&#39;: None,
        &#39;pos_norm&#39;: None,
        }

    tris = surf[&#39;pos&#39;][surf[&#39;tri&#39;]]

    if not normals:
        return surf

    surf[&#39;tri_norm&#39;] = cross(tris[:, 1, :] - tris[:, 0, :], tris[:, 2, :] - tris[:, 0, :])
    surf[&#39;tri_norm&#39;] /= norm(surf[&#39;tri_norm&#39;], axis=1)[:, None]

    with Pool() as p:
        f_compute = partial(_average_normal_per_vertex, tri_norm=surf[&#39;tri_norm&#39;], tri=surf[&#39;tri&#39;])
        vert_norm = p.map(f_compute, range(surf[&#39;pos&#39;].shape[0]))

    surf[&#39;pos_norm&#39;] = array(vert_norm)
    surf[&#39;pos_norm&#39;] /= norm(surf[&#39;pos_norm&#39;], axis=1)[:, None]

    return surf</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_surface_ras_shift"><code class="name flex">
<span>def <span class="ident">read_surface_ras_shift</span></span>(<span>T1_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Freesurfer uses two coordinate systems: one for volumes ("RAS") and
one for surfaces ("tkReg", "tkRAS", and "Surface RAS").
To get from surface to volume coordinates, add these numbers.
To get from volume to surface coordinates, substract these numbers.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T1_path</code></strong> :&ensp;<code>str</code></dt>
<dd>file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>3 array</code></dt>
<dd>offset between volume and surface (tkRAS)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_surface_ras_shift(T1_path):
    &#34;&#34;&#34;Freesurfer uses two coordinate systems: one for volumes (&#34;RAS&#34;) and
    one for surfaces (&#34;tkReg&#34;, &#34;tkRAS&#34;, and &#34;Surface RAS&#34;).
    To get from surface to volume coordinates, add these numbers.
    To get from volume to surface coordinates, substract these numbers.

    Parameters
    ----------
    T1_path : str
        file path to any .mgz file in the freesurfer folder (e.g. brain.mgz)

    Returns
    -------
    3 array
        offset between volume and surface (tkRAS)
    &#34;&#34;&#34;
    T1 = nload(str(T1_path))

    return T1.header[&#39;Pxyz_c&#39;]</code></pre>
</details>
</dd>
<dt id="gridloc.io.read_volume"><code class="name flex">
<span>def <span class="ident">read_volume</span></span>(<span>volume_file, threshold=-inf)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_volume(volume_file, threshold=-Inf):
    volume = nload(str(volume_file))
    data = volume.get_data()
    i = data &gt;= threshold

    d_ = dtype([
        (&#39;pos&#39;, &#39;f4&#39;, (3, )),
        (&#39;value&#39;, &#39;f4&#39;),
        ])
    output = zeros(i.sum(), dtype=d_)

    output[&#39;pos&#39;] = apply_affine(volume.affine, array(where(i)).T)
    output[&#39;value&#39;] = data[i]

    return output</code></pre>
</details>
</dd>
<dt id="gridloc.io.write_ecog2d"><code class="name flex">
<span>def <span class="ident">write_ecog2d</span></span>(<span>ecog_file, ecog2d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_ecog2d(ecog_file, ecog2d):
    savetxt(ecog_file, ecog2d[&#39;ecog&#39;], fmt=&#39;%.8f&#39;, delimiter=&#39;\t&#39;)</code></pre>
</details>
</dd>
<dt id="gridloc.io.write_grid2d"><code class="name flex">
<span>def <span class="ident">write_grid2d</span></span>(<span>grid_file, grid2d)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_grid2d(grid_file, grid2d):
    with grid_file.open(&#39;w&#39;) as f:
        for row in grid2d[&#39;label&#39;]:
            f.write(&#39;\t&#39;.join(row) + &#39;\n&#39;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gridloc" href="index.html">gridloc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="gridloc.io.export_grid" href="#gridloc.io.export_grid">export_grid</a></code></li>
<li><code><a title="gridloc.io.export_transform" href="#gridloc.io.export_transform">export_transform</a></code></li>
<li><code><a title="gridloc.io.read_ecog2d" href="#gridloc.io.read_ecog2d">read_ecog2d</a></code></li>
<li><code><a title="gridloc.io.read_grid2d" href="#gridloc.io.read_grid2d">read_grid2d</a></code></li>
<li><code><a title="gridloc.io.read_surf" href="#gridloc.io.read_surf">read_surf</a></code></li>
<li><code><a title="gridloc.io.read_surface_ras_shift" href="#gridloc.io.read_surface_ras_shift">read_surface_ras_shift</a></code></li>
<li><code><a title="gridloc.io.read_volume" href="#gridloc.io.read_volume">read_volume</a></code></li>
<li><code><a title="gridloc.io.write_ecog2d" href="#gridloc.io.write_ecog2d">write_ecog2d</a></code></li>
<li><code><a title="gridloc.io.write_grid2d" href="#gridloc.io.write_grid2d">write_grid2d</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>