<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>gridloc.fitting API documentation</title>
<meta name="description" content="Functions to compute the actual fitting of the grid onto the brain surface" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>gridloc.fitting</code></h1>
</header>
<section id="section-intro">
<p>Functions to compute the actual fitting of the grid onto the brain surface</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions to compute the actual fitting of the grid onto the brain surface
&#34;&#34;&#34;
from scipy.optimize import brute, minimize
from scipy.stats import spearmanr
from multiprocessing import Pool
from numpy.linalg import norm
from numpy import arange, array, argmin, intersect1d, corrcoef
from logging import getLogger
from datetime import datetime
from json import dump

try:
    import mkl
except ImportError:
    mkl = None

from .geometry import search_grid
from .morphology.distance import compute_distance
from .vascular.sphere import compute_vasculature
from .construct import construct_grid
from .io import read_surf, read_surface_ras_shift, read_volume, write_tsv
from .viz import plot_results
from .examine import measure_distances, measure_angles
from .utils import be_nice, match_labels, normalize

lg = getLogger(__name__)


def fitting(T1_file, dura_file, pial_file, initial, ecog, output, angio_file=None,
            angio_threshold=None, correlation=&#39;parametric&#39;, ranges={}, method=&#39;brute&#39;):
    &#34;&#34;&#34;Fit the brain activity onto the surface

    Parameters
    ----------
    T1_file : path
        path to T1 image (in particular, the T1.mgz from freesurfer)
    dura_file : path
        path to dura surface (for example, the smoothed pial surface)
    pial_file : path
        path to pial surface (in particular, the lh.pial or rh.pial from freesurfer)
    initial : dict
        start position for search, with fields:
            - label : label for the reference electrode
            - RAS : initial location for the reference electrode
            - rotation : degree of rotation of the grid (in degrees, 0° is roughly pointing up)
    angio_file : path or None
        path to angiogram (in NIfTI format). Optional.
    angio_threshold : float
        value to threshold the angio_file. Optional.
    correlation : str
        &#39;parametric&#39; (Pearson) or &#39;nonparametric&#39; (rank)
    method : str
        &#39;simplex&#39;, &#39;brute&#39;
    ranges : dict of lists
        keys are x-direction, y-direction, rotation

    Returns
    -------
    instance of grid2d
        grid2d with best positions
    &#34;&#34;&#34;
    start_time = datetime.now()

    ras_shift = read_surface_ras_shift(T1_file)
    lg.debug(f&#39;Reading positions and computing normals of {dura_file}&#39;)
    dura = read_surf(dura_file, ras_shift=ras_shift)
    lg.debug(f&#39;Reading positions of {pial_file}&#39;)
    pial = read_surf(pial_file, normals=False, ras_shift=ras_shift)

    if angio_file is not None and angio_file:
        lg.debug(f&#39;Reading angiogram from {angio_file} and thresholding at {angio_threshold}&#39;)
        angio = read_volume(angio_file, angio_threshold)
    else:
        angio = None

    ref_label = initial[&#39;label&#39;]
    init_rot = initial[&#39;rotation&#39;]
    init_ras = array(initial[&#39;RAS&#39;])
    init_vert = argmin(norm(dura[&#39;pos&#39;] - init_ras, axis=1))
    vert_dist = norm(init_ras - dura[&#39;pos&#39;][init_vert])

    lg.debug(f&#39;Target RAS: {init_ras}, vertex #{init_vert} RAS: {dura[&#34;pos&#34;][init_vert]} (distance = {vert_dist:0.3}mm)&#39;)
    lg.info(f&#39;Starting position for {ref_label} is vertex #{init_vert} with orientation {initial[&#34;rotation&#34;]}&#39;)

    # start position is init_vert, plus some rotation
    init = array([0, 0, init_rot])

    # make sure that the last point is included in the range
    for k, v in ranges.items():
        ranges[k][1], ranges[k][2] = ranges[k][2], ranges[k][1]
        ranges[k][1] += ranges[k][2]

    # has to be a tuple
    minimizer_args = (
        dura,  # 0
        init_vert,  # 1
        ref_label,  # 2
        ecog,  # 3
        pial,  # 4
        angio,  # 5
        correlation,  # 6
        ranges,  # 7
        )

    if method == &#39;simplex&#39;:
        m = fitting_simplex(corr_ecog_model, init, minimizer_args)
        best_fit = m.x

    elif method == &#39;brute&#39;:
        m = fitting_brute(corr_ecog_model, init, minimizer_args)
        best_fit = m[0]

    end_time = datetime.now()
    comp_dur = (end_time - start_time).total_seconds()
    lg.debug(f&#39;Model fitting took {comp_dur:1.0f}s&#39;)

    # create grid with best values
    x, y, rotation = best_fit
    model = corr_ecog_model(best_fit, *minimizer_args[:-1], final=True)
    lg.info(f&#39;Best fit at {x: 8.3f}mm {y: 8.3f}mm {rotation: 8.3f}° (vert{model[&#34;vert&#34;]: 6d}) = {model[&#34;cc&#34;]: 8.3f} (vascular contribution: {model[&#34;percent_vasc&#34;]:.2f}%)&#39;)

    measure_distances(model[&#39;grid&#39;])
    measure_angles(model[&#39;grid&#39;])

    output = output / (&#39;bestfit_&#39; + method + &#39;_&#39; + correlation + &#39;_&#39; + start_time.strftime(&#39;%Y%m%d_%H%M%S&#39;))
    output.mkdir(parents=True)

    out = {
        &#39;ref_label&#39;: ref_label,
        &#39;surface&#39;: str(dura_file),
        &#39;vertex&#39;: int(model[&#39;vert&#39;]),
        &#39;pos&#39;: list(dura[&#39;pos&#39;][model[&#39;vert&#39;], :]),
        &#39;normals&#39;: list(dura[&#39;pos_norm&#39;][model[&#39;vert&#39;], :]),
        &#39;rotation&#39;: rotation,
        &#39;percent_vasculature&#39;: model[&#39;percent_vasc&#39;],
        &#39;r2&#39;: model[&#39;cc&#39;],
        &#39;duration&#39;: comp_dur,
        }
    results_file = output / &#39;results.json&#39;
    with results_file.open(&#39;w&#39;) as f:
        dump(out, f, indent=2)

    grid_file = output / &#39;electrodes&#39;
    write_tsv(model[&#39;grid&#39;][&#39;label&#39;], model[&#39;grid&#39;][&#39;pos&#39;], grid_file)
    lg.debug(f&#39;Exported electrodes to {grid_file} (coordinates in MRI volume space, not mesh space)&#39;)

    plot_results(model, pial, ras_shift, output)
    return model[&#39;grid&#39;]


def corr_ecog_model(x0, dura, ref_vert, ref_label, ecog, pial, angio=None,
                    correlation=None, ranges=None, final=False):
    &#34;&#34;&#34;Main model to minimize

    Parameters
    ----------
    ranges : None
        ignored, but easier to pass when working with arguments

    &#34;&#34;&#34;
    x, y, rotation = x0
    start_vert = search_grid(dura, ref_vert, x, y)
    grid = construct_grid(dura, start_vert, ref_label, ecog[&#39;label&#39;], rotation=rotation)

    morpho = compute_distance(grid, pial)

    if angio is not None and angio is not False:
        vasc = compute_vasculature(grid, angio)
        e, m, v = match_labels(ecog, morpho, vasc)

    else:
        e, m = match_labels(ecog, morpho)
        v = vasc = None

    i, cc = compare_models(e, m, v, correlation=correlation)
    if not final:
        lg.debug(f&#39;{x0[0]: 8.3f}mm {x0[1]: 8.3f}mm {x0[2]: 8.3f}° (vert{start_vert: 6d}) = {cc: 8.3f} (vascular contribution: {100 * (1 - i):.2f}%)&#39;)

    if final:
        return {
            &#39;ecog&#39;: ecog,
            &#39;vert&#39;: start_vert,
            &#39;grid&#39;: grid,
            &#39;morpho&#39;: morpho,
            &#39;vasc&#39;: vasc,
            &#39;percent_vasc&#39;: 100 * (1 - i),
            &#39;cc&#39;: cc,
            }

    else:
        return cc


def compare_models(E, M, V=None, correlation=&#39;parametric&#39;):

    E = normalize(E)
    M = normalize(M)

    if V is not None:
        V = normalize(V)
        WEIGHTS = arange(0, 1.1, 0.1)
    else:
        V = 0
        WEIGHTS = [1, ]

    x = []
    for weight in WEIGHTS:
        prediction = weight * M + (1 - weight) * V

        if correlation == &#39;parametric&#39;:
            c = corrcoef(E, prediction)[0, 1]
        else:
            c = spearmanr(E, prediction).correlation

        x.append(c)

    x = array(x)
    i = argmin(x)

    return WEIGHTS[i], x[i]


def corrcoef_match(ecog, estimate, field=&#39;morphology&#39;):
    &#34;&#34;&#34;correlation but make sure that the labels match
    &#34;&#34;&#34;
    good = ecog[&#39;label&#39;][ecog[&#39;good&#39;]]
    ecog_id = intersect1d(ecog[&#39;label&#39;], good, return_indices=True)[1]
    a = ecog[&#39;ecog&#39;].flatten(&#39;C&#39;)[ecog_id]

    estimate_id = intersect1d(estimate[&#39;label&#39;], good, return_indices=True)[1]
    b = estimate[field].flatten(&#39;C&#39;)[estimate_id]

    return corrcoef(a, b)[0, 1]


def fitting_brute(func, init, args):

    # shift rotation by initial value
    # for x and y, the default value MUST be zero, because we start at
    # the reference vertex
    rotation = args[7][&#39;rotation&#39;]
    rotation[0] += init[2]
    rotation[1] += init[2]

    ranges = (
        slice(*args[7][&#39;x&#39;]),
        slice(*args[7][&#39;y&#39;]),
        slice(*rotation),
        )

    if mkl is not None:
        mkl.set_num_threads(2)

    with Pool(initializer=be_nice) as p:
        res = brute(
            corr_ecog_model,
            ranges,
            args=args,
            disp=True,
            workers=p.map,
            full_output=True,
            finish=fitting_simplex,
            )

    return res


def fitting_simplex(func, init, args):
    lg.info(f&#39;Starting point: {init[0]: 8.3f}mm {init[1]: 8.3f}mm {init[2]: 8.3f}°. Now applying simplex&#39;)

    x, y, rotation = init
    ranges = args[7]
    simplex = array([
        [x - ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x + ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x - ranges[&#39;x&#39;][2] / 2, y + ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x - ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation + ranges[&#39;rotation&#39;][2] / 2],
        ])

    m = minimize(
        func,
        array([0, 0, 0]),  # ignored
        method=&#39;Nelder-Mead&#39;,
        args=args,
        options=dict(
            maxiter=100,
            initial_simplex=simplex,
            xatol=0.5,
            fatol=0.05,
            ),
        )

    return m</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="gridloc.fitting.compare_models"><code class="name flex">
<span>def <span class="ident">compare_models</span></span>(<span>E, M, V=None, correlation='parametric')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_models(E, M, V=None, correlation=&#39;parametric&#39;):

    E = normalize(E)
    M = normalize(M)

    if V is not None:
        V = normalize(V)
        WEIGHTS = arange(0, 1.1, 0.1)
    else:
        V = 0
        WEIGHTS = [1, ]

    x = []
    for weight in WEIGHTS:
        prediction = weight * M + (1 - weight) * V

        if correlation == &#39;parametric&#39;:
            c = corrcoef(E, prediction)[0, 1]
        else:
            c = spearmanr(E, prediction).correlation

        x.append(c)

    x = array(x)
    i = argmin(x)

    return WEIGHTS[i], x[i]</code></pre>
</details>
</dd>
<dt id="gridloc.fitting.corr_ecog_model"><code class="name flex">
<span>def <span class="ident">corr_ecog_model</span></span>(<span>x0, dura, ref_vert, ref_label, ecog, pial, angio=None, correlation=None, ranges=None, final=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Main model to minimize</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ranges</code></strong> :&ensp;<code>None</code></dt>
<dd>ignored, but easier to pass when working with arguments</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corr_ecog_model(x0, dura, ref_vert, ref_label, ecog, pial, angio=None,
                    correlation=None, ranges=None, final=False):
    &#34;&#34;&#34;Main model to minimize

    Parameters
    ----------
    ranges : None
        ignored, but easier to pass when working with arguments

    &#34;&#34;&#34;
    x, y, rotation = x0
    start_vert = search_grid(dura, ref_vert, x, y)
    grid = construct_grid(dura, start_vert, ref_label, ecog[&#39;label&#39;], rotation=rotation)

    morpho = compute_distance(grid, pial)

    if angio is not None and angio is not False:
        vasc = compute_vasculature(grid, angio)
        e, m, v = match_labels(ecog, morpho, vasc)

    else:
        e, m = match_labels(ecog, morpho)
        v = vasc = None

    i, cc = compare_models(e, m, v, correlation=correlation)
    if not final:
        lg.debug(f&#39;{x0[0]: 8.3f}mm {x0[1]: 8.3f}mm {x0[2]: 8.3f}° (vert{start_vert: 6d}) = {cc: 8.3f} (vascular contribution: {100 * (1 - i):.2f}%)&#39;)

    if final:
        return {
            &#39;ecog&#39;: ecog,
            &#39;vert&#39;: start_vert,
            &#39;grid&#39;: grid,
            &#39;morpho&#39;: morpho,
            &#39;vasc&#39;: vasc,
            &#39;percent_vasc&#39;: 100 * (1 - i),
            &#39;cc&#39;: cc,
            }

    else:
        return cc</code></pre>
</details>
</dd>
<dt id="gridloc.fitting.corrcoef_match"><code class="name flex">
<span>def <span class="ident">corrcoef_match</span></span>(<span>ecog, estimate, field='morphology')</span>
</code></dt>
<dd>
<div class="desc"><p>correlation but make sure that the labels match</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corrcoef_match(ecog, estimate, field=&#39;morphology&#39;):
    &#34;&#34;&#34;correlation but make sure that the labels match
    &#34;&#34;&#34;
    good = ecog[&#39;label&#39;][ecog[&#39;good&#39;]]
    ecog_id = intersect1d(ecog[&#39;label&#39;], good, return_indices=True)[1]
    a = ecog[&#39;ecog&#39;].flatten(&#39;C&#39;)[ecog_id]

    estimate_id = intersect1d(estimate[&#39;label&#39;], good, return_indices=True)[1]
    b = estimate[field].flatten(&#39;C&#39;)[estimate_id]

    return corrcoef(a, b)[0, 1]</code></pre>
</details>
</dd>
<dt id="gridloc.fitting.fitting"><code class="name flex">
<span>def <span class="ident">fitting</span></span>(<span>T1_file, dura_file, pial_file, initial, ecog, output, angio_file=None, angio_threshold=None, correlation='parametric', ranges={}, method='brute')</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the brain activity onto the surface</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>T1_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to T1 image (in particular, the T1.mgz from freesurfer)</dd>
<dt><strong><code>dura_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to dura surface (for example, the smoothed pial surface)</dd>
<dt><strong><code>pial_file</code></strong> :&ensp;<code>path</code></dt>
<dd>path to pial surface (in particular, the lh.pial or rh.pial from freesurfer)</dd>
<dt><strong><code>initial</code></strong> :&ensp;<code>dict</code></dt>
<dd>start position for search, with fields:
- label : label for the reference electrode
- RAS : initial location for the reference electrode
- rotation : degree of rotation of the grid (in degrees, 0° is roughly pointing up)</dd>
<dt><strong><code>angio_file</code></strong> :&ensp;<code>path</code> or <code>None</code></dt>
<dd>path to angiogram (in NIfTI format). Optional.</dd>
<dt><strong><code>angio_threshold</code></strong> :&ensp;<code>float</code></dt>
<dd>value to threshold the angio_file. Optional.</dd>
<dt><strong><code>correlation</code></strong> :&ensp;<code>str</code></dt>
<dd>'parametric' (Pearson) or 'nonparametric' (rank)</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>'simplex', 'brute'</dd>
<dt><strong><code>ranges</code></strong> :&ensp;<code>dict</code> of <code>lists</code></dt>
<dd>keys are x-direction, y-direction, rotation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>instance</code> of <code>grid2d</code></dt>
<dd>grid2d with best positions</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitting(T1_file, dura_file, pial_file, initial, ecog, output, angio_file=None,
            angio_threshold=None, correlation=&#39;parametric&#39;, ranges={}, method=&#39;brute&#39;):
    &#34;&#34;&#34;Fit the brain activity onto the surface

    Parameters
    ----------
    T1_file : path
        path to T1 image (in particular, the T1.mgz from freesurfer)
    dura_file : path
        path to dura surface (for example, the smoothed pial surface)
    pial_file : path
        path to pial surface (in particular, the lh.pial or rh.pial from freesurfer)
    initial : dict
        start position for search, with fields:
            - label : label for the reference electrode
            - RAS : initial location for the reference electrode
            - rotation : degree of rotation of the grid (in degrees, 0° is roughly pointing up)
    angio_file : path or None
        path to angiogram (in NIfTI format). Optional.
    angio_threshold : float
        value to threshold the angio_file. Optional.
    correlation : str
        &#39;parametric&#39; (Pearson) or &#39;nonparametric&#39; (rank)
    method : str
        &#39;simplex&#39;, &#39;brute&#39;
    ranges : dict of lists
        keys are x-direction, y-direction, rotation

    Returns
    -------
    instance of grid2d
        grid2d with best positions
    &#34;&#34;&#34;
    start_time = datetime.now()

    ras_shift = read_surface_ras_shift(T1_file)
    lg.debug(f&#39;Reading positions and computing normals of {dura_file}&#39;)
    dura = read_surf(dura_file, ras_shift=ras_shift)
    lg.debug(f&#39;Reading positions of {pial_file}&#39;)
    pial = read_surf(pial_file, normals=False, ras_shift=ras_shift)

    if angio_file is not None and angio_file:
        lg.debug(f&#39;Reading angiogram from {angio_file} and thresholding at {angio_threshold}&#39;)
        angio = read_volume(angio_file, angio_threshold)
    else:
        angio = None

    ref_label = initial[&#39;label&#39;]
    init_rot = initial[&#39;rotation&#39;]
    init_ras = array(initial[&#39;RAS&#39;])
    init_vert = argmin(norm(dura[&#39;pos&#39;] - init_ras, axis=1))
    vert_dist = norm(init_ras - dura[&#39;pos&#39;][init_vert])

    lg.debug(f&#39;Target RAS: {init_ras}, vertex #{init_vert} RAS: {dura[&#34;pos&#34;][init_vert]} (distance = {vert_dist:0.3}mm)&#39;)
    lg.info(f&#39;Starting position for {ref_label} is vertex #{init_vert} with orientation {initial[&#34;rotation&#34;]}&#39;)

    # start position is init_vert, plus some rotation
    init = array([0, 0, init_rot])

    # make sure that the last point is included in the range
    for k, v in ranges.items():
        ranges[k][1], ranges[k][2] = ranges[k][2], ranges[k][1]
        ranges[k][1] += ranges[k][2]

    # has to be a tuple
    minimizer_args = (
        dura,  # 0
        init_vert,  # 1
        ref_label,  # 2
        ecog,  # 3
        pial,  # 4
        angio,  # 5
        correlation,  # 6
        ranges,  # 7
        )

    if method == &#39;simplex&#39;:
        m = fitting_simplex(corr_ecog_model, init, minimizer_args)
        best_fit = m.x

    elif method == &#39;brute&#39;:
        m = fitting_brute(corr_ecog_model, init, minimizer_args)
        best_fit = m[0]

    end_time = datetime.now()
    comp_dur = (end_time - start_time).total_seconds()
    lg.debug(f&#39;Model fitting took {comp_dur:1.0f}s&#39;)

    # create grid with best values
    x, y, rotation = best_fit
    model = corr_ecog_model(best_fit, *minimizer_args[:-1], final=True)
    lg.info(f&#39;Best fit at {x: 8.3f}mm {y: 8.3f}mm {rotation: 8.3f}° (vert{model[&#34;vert&#34;]: 6d}) = {model[&#34;cc&#34;]: 8.3f} (vascular contribution: {model[&#34;percent_vasc&#34;]:.2f}%)&#39;)

    measure_distances(model[&#39;grid&#39;])
    measure_angles(model[&#39;grid&#39;])

    output = output / (&#39;bestfit_&#39; + method + &#39;_&#39; + correlation + &#39;_&#39; + start_time.strftime(&#39;%Y%m%d_%H%M%S&#39;))
    output.mkdir(parents=True)

    out = {
        &#39;ref_label&#39;: ref_label,
        &#39;surface&#39;: str(dura_file),
        &#39;vertex&#39;: int(model[&#39;vert&#39;]),
        &#39;pos&#39;: list(dura[&#39;pos&#39;][model[&#39;vert&#39;], :]),
        &#39;normals&#39;: list(dura[&#39;pos_norm&#39;][model[&#39;vert&#39;], :]),
        &#39;rotation&#39;: rotation,
        &#39;percent_vasculature&#39;: model[&#39;percent_vasc&#39;],
        &#39;r2&#39;: model[&#39;cc&#39;],
        &#39;duration&#39;: comp_dur,
        }
    results_file = output / &#39;results.json&#39;
    with results_file.open(&#39;w&#39;) as f:
        dump(out, f, indent=2)

    grid_file = output / &#39;electrodes&#39;
    write_tsv(model[&#39;grid&#39;][&#39;label&#39;], model[&#39;grid&#39;][&#39;pos&#39;], grid_file)
    lg.debug(f&#39;Exported electrodes to {grid_file} (coordinates in MRI volume space, not mesh space)&#39;)

    plot_results(model, pial, ras_shift, output)
    return model[&#39;grid&#39;]</code></pre>
</details>
</dd>
<dt id="gridloc.fitting.fitting_brute"><code class="name flex">
<span>def <span class="ident">fitting_brute</span></span>(<span>func, init, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitting_brute(func, init, args):

    # shift rotation by initial value
    # for x and y, the default value MUST be zero, because we start at
    # the reference vertex
    rotation = args[7][&#39;rotation&#39;]
    rotation[0] += init[2]
    rotation[1] += init[2]

    ranges = (
        slice(*args[7][&#39;x&#39;]),
        slice(*args[7][&#39;y&#39;]),
        slice(*rotation),
        )

    if mkl is not None:
        mkl.set_num_threads(2)

    with Pool(initializer=be_nice) as p:
        res = brute(
            corr_ecog_model,
            ranges,
            args=args,
            disp=True,
            workers=p.map,
            full_output=True,
            finish=fitting_simplex,
            )

    return res</code></pre>
</details>
</dd>
<dt id="gridloc.fitting.fitting_simplex"><code class="name flex">
<span>def <span class="ident">fitting_simplex</span></span>(<span>func, init, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fitting_simplex(func, init, args):
    lg.info(f&#39;Starting point: {init[0]: 8.3f}mm {init[1]: 8.3f}mm {init[2]: 8.3f}°. Now applying simplex&#39;)

    x, y, rotation = init
    ranges = args[7]
    simplex = array([
        [x - ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x + ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x - ranges[&#39;x&#39;][2] / 2, y + ranges[&#39;y&#39;][2] / 2, rotation - ranges[&#39;rotation&#39;][2] / 2],
        [x - ranges[&#39;x&#39;][2] / 2, y - ranges[&#39;y&#39;][2] / 2, rotation + ranges[&#39;rotation&#39;][2] / 2],
        ])

    m = minimize(
        func,
        array([0, 0, 0]),  # ignored
        method=&#39;Nelder-Mead&#39;,
        args=args,
        options=dict(
            maxiter=100,
            initial_simplex=simplex,
            xatol=0.5,
            fatol=0.05,
            ),
        )

    return m</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="gridloc" href="index.html">gridloc</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="gridloc.fitting.compare_models" href="#gridloc.fitting.compare_models">compare_models</a></code></li>
<li><code><a title="gridloc.fitting.corr_ecog_model" href="#gridloc.fitting.corr_ecog_model">corr_ecog_model</a></code></li>
<li><code><a title="gridloc.fitting.corrcoef_match" href="#gridloc.fitting.corrcoef_match">corrcoef_match</a></code></li>
<li><code><a title="gridloc.fitting.fitting" href="#gridloc.fitting.fitting">fitting</a></code></li>
<li><code><a title="gridloc.fitting.fitting_brute" href="#gridloc.fitting.fitting_brute">fitting_brute</a></code></li>
<li><code><a title="gridloc.fitting.fitting_simplex" href="#gridloc.fitting.fitting_simplex">fitting_simplex</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>